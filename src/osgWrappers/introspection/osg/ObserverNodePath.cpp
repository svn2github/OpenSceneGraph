// ***************************************************************************
//
//   Generated automatically by genwrapper.
//   Please DO NOT EDIT this file!
//
// ***************************************************************************

#include <osgIntrospection/ReflectionMacros>
#include <osgIntrospection/TypedMethodInfo>
#include <osgIntrospection/StaticMethodInfo>
#include <osgIntrospection/Attributes>

#include <osg/Node>
#include <osg/ObserverNodePath>

// Must undefine IN and OUT macros defined in Windows headers
#ifdef IN
#undef IN
#endif
#ifdef OUT
#undef OUT
#endif

#include <osg/observer_ptr>
        
BEGIN_VALUE_REFLECTOR(osg::ObserverNodePath)
	I_DeclaringFile("osg/ObserverNodePath");
	I_Constructor0(____ObserverNodePath,
	               "",
	               "");
	I_Constructor1(IN, const osg::ObserverNodePath &, rhs,
	               Properties::NON_EXPLICIT,
	               ____ObserverNodePath__C5_ObserverNodePath_R1,
	               "",
	               "");
	I_Constructor1(IN, const osg::NodePath &, nodePath,
	               Properties::NON_EXPLICIT,
	               ____ObserverNodePath__C5_osg_NodePath_R1,
	               "",
	               "");
	I_Method1(void, setNodePathTo, IN, osg::Node *, node,
	          Properties::NON_VIRTUAL,
	          __void__setNodePathTo__osg_Node_P1,
	          "get the NodePath from the first parental chain back to root, plus the specified node. ",
	          "");
	I_Method1(void, setNodePath, IN, const osg::RefNodePath &, nodePath,
	          Properties::NON_VIRTUAL,
	          __void__setNodePath__C5_osg_RefNodePath_R1,
	          "",
	          "");
	I_Method1(void, setNodePath, IN, const osg::NodePath &, nodePath,
	          Properties::NON_VIRTUAL,
	          __void__setNodePath__C5_osg_NodePath_R1,
	          "",
	          "");
	I_Method0(void, clearNodePath,
	          Properties::NON_VIRTUAL,
	          __void__clearNodePath,
	          "",
	          "");
	I_Method1(bool, getRefNodePath, IN, osg::RefNodePath &, refNodePath,
	          Properties::NON_VIRTUAL,
	          __bool__getRefNodePath__RefNodePath_R1,
	          "Get a thread safe RefNodePath, return true if NodePath is valid. ",
	          "");
	I_Method1(bool, getNodePath, IN, osg::NodePath &, nodePath,
	          Properties::NON_VIRTUAL,
	          __bool__getNodePath__NodePath_R1,
	          "Get a lightweight NodePath that isn't thread safe but may be safely used in single threaded applications, or when its known that the NodePath won't be invalidated during usage of the NodePath. ",
	          "return true if NodePath is valid. ");
	I_Method0(bool, empty,
	          Properties::NON_VIRTUAL,
	          __bool__empty,
	          "",
	          "");
	I_ProtectedMethod1(void, _setNodePath, IN, const osg::NodePath &, nodePath,
	                   Properties::NON_VIRTUAL,
	                   Properties::NON_CONST,
	                   __void___setNodePath__C5_osg_NodePath_R1,
	                   "",
	                   "");
	I_ProtectedMethod0(void, _clearNodePath,
	                   Properties::NON_VIRTUAL,
	                   Properties::NON_CONST,
	                   __void___clearNodePath,
	                   "",
	                   "");
	I_SimpleProperty(const osg::RefNodePath &, NodePath, 
	                 0, 
	                 __void__setNodePath__C5_osg_RefNodePath_R1);
	I_SimpleProperty(osg::Node *, NodePathTo, 
	                 0, 
	                 __void__setNodePathTo__osg_Node_P1);
END_REFLECTOR

TYPE_NAME_ALIAS(std::vector< osg::ref_ptr< osg::Node > >, osg::RefNodePath)

