// ***************************************************************************
//
//   Generated automatically by genwrapper.
//   Please DO NOT EDIT this file!
//
// ***************************************************************************

#include <osgIntrospection/ReflectionMacros>
#include <osgIntrospection/TypedMethodInfo>
#include <osgIntrospection/StaticMethodInfo>
#include <osgIntrospection/Attributes>

#include <osg/BoundingSphere>
#include <osg/CopyOp>
#include <osg/Image>
#include <osg/Matrix>
#include <osg/NodeVisitor>
#include <osg/Object>
#include <osgVolume/Brick>
#include <osgVolume/Volume>
#include <osgVolume/VolumeTechnique>

// Must undefine IN and OUT macros defined in Windows headers
#ifdef IN
#undef IN
#endif
#ifdef OUT
#undef OUT
#endif

BEGIN_OBJECT_REFLECTOR(osgVolume::Brick)
	I_DeclaringFile("osgVolume/Brick");
	I_BaseType(osg::Group);
	I_Constructor0(____Brick,
	               "",
	               "");
	I_ConstructorWithDefaults2(IN, const osgVolume::Brick &, x, , IN, const osg::CopyOp &, copyop, osg::CopyOp::SHALLOW_COPY,
	                           ____Brick__C5_Brick_R1__C5_osg_CopyOp_R1,
	                           "Copy constructor using CopyOp to manage deep vs shallow copy. ",
	                           "");
	I_Method0(osg::Object *, cloneType,
	          Properties::VIRTUAL,
	          __osg_Object_P1__cloneType,
	          "clone an object of the same type as the node. ",
	          "");
	I_Method1(osg::Object *, clone, IN, const osg::CopyOp &, copyop,
	          Properties::VIRTUAL,
	          __osg_Object_P1__clone__C5_osg_CopyOp_R1,
	          "return a clone of a node, with Object* return type. ",
	          "");
	I_Method1(bool, isSameKindAs, IN, const osg::Object *, obj,
	          Properties::VIRTUAL,
	          __bool__isSameKindAs__C5_osg_Object_P1,
	          "return true if this and obj are of the same kind of object. ",
	          "");
	I_Method0(const char *, className,
	          Properties::VIRTUAL,
	          __C5_char_P1__className,
	          "return the name of the node's class type. ",
	          "");
	I_Method0(const char *, libraryName,
	          Properties::VIRTUAL,
	          __C5_char_P1__libraryName,
	          "return the name of the node's library. ",
	          "");
	I_Method1(void, accept, IN, osg::NodeVisitor &, nv,
	          Properties::VIRTUAL,
	          __void__accept__osg_NodeVisitor_R1,
	          "Visitor Pattern : calls the apply method of a NodeVisitor with this node's type. ",
	          "");
	I_Method1(void, traverse, IN, osg::NodeVisitor &, nv,
	          Properties::VIRTUAL,
	          __void__traverse__osg_NodeVisitor_R1,
	          "Traverse downwards : calls children's accept method with NodeVisitor. ",
	          "");
	I_Method0(void, init,
	          Properties::NON_VIRTUAL,
	          __void__init,
	          "Call init on any attached TerrainTechnique. ",
	          "");
	I_Method1(void, setVolume, IN, osgVolume::Volume *, ts,
	          Properties::NON_VIRTUAL,
	          __void__setVolume__Volume_P1,
	          "Set the Volume that this Volume tile is a member of. ",
	          "");
	I_Method0(osgVolume::Volume *, getVolume,
	          Properties::NON_VIRTUAL,
	          __Volume_P1__getVolume,
	          "Get the Volume that this Volume tile is a member of. ",
	          "");
	I_Method0(const osgVolume::Volume *, getVolume,
	          Properties::NON_VIRTUAL,
	          __C5_Volume_P1__getVolume,
	          "Get the const Volume that this Volume tile is a member of. ",
	          "");
	I_Method1(void, setBrickID, IN, const osgVolume::BrickID &, brickID,
	          Properties::NON_VIRTUAL,
	          __void__setBrickID__C5_BrickID_R1,
	          "Set the BrickID (layer, x,y) of the Brick. ",
	          "The BrickID is used so it can be located by its neighbours via the enclosing Terrain node that manages a map of BrickID to TerraiTiles. ");
	I_Method0(const osgVolume::BrickID &, getBrickID,
	          Properties::NON_VIRTUAL,
	          __C5_BrickID_R1__getBrickID,
	          "Get the BrickID (layer, x,y) of the Brick. ",
	          "");
	I_Method1(void, setLocator, IN, osg::RefMatrix *, locator,
	          Properties::NON_VIRTUAL,
	          __void__setLocator__osg_RefMatrix_P1,
	          "",
	          "");
	I_Method0(osg::RefMatrix *, getLocator,
	          Properties::NON_VIRTUAL,
	          __osg_RefMatrix_P1__getLocator,
	          "",
	          "");
	I_Method0(const osg::RefMatrix *, getLocator,
	          Properties::NON_VIRTUAL,
	          __C5_osg_RefMatrix_P1__getLocator,
	          "",
	          "");
	I_Method1(void, setImage, IN, osg::Image *, image,
	          Properties::NON_VIRTUAL,
	          __void__setImage__osg_Image_P1,
	          "",
	          "");
	I_Method0(osg::Image *, getImage,
	          Properties::NON_VIRTUAL,
	          __osg_Image_P1__getImage,
	          "",
	          "");
	I_Method0(const osg::Image *, getImage,
	          Properties::NON_VIRTUAL,
	          __C5_osg_Image_P1__getImage,
	          "",
	          "");
	I_Method1(void, setVolumeTechnique, IN, osgVolume::VolumeTechnique *, VolumeTechnique,
	          Properties::NON_VIRTUAL,
	          __void__setVolumeTechnique__VolumeTechnique_P1,
	          "Set the VolumeTechnique. ",
	          "");
	I_Method0(osgVolume::VolumeTechnique *, getVolumeTechnique,
	          Properties::NON_VIRTUAL,
	          __VolumeTechnique_P1__getVolumeTechnique,
	          "Get the VolumeTechnique. ",
	          "");
	I_Method0(const osgVolume::VolumeTechnique *, getVolumeTechnique,
	          Properties::NON_VIRTUAL,
	          __C5_VolumeTechnique_P1__getVolumeTechnique,
	          "Get the const VolumeTechnique. ",
	          "");
	I_Method1(void, setDirty, IN, bool, dirty,
	          Properties::NON_VIRTUAL,
	          __void__setDirty__bool,
	          "Set the dirty flag on/off. ",
	          "");
	I_Method0(bool, getDirty,
	          Properties::NON_VIRTUAL,
	          __bool__getDirty,
	          "return true if the tile is dirty and needs to be updated, ",
	          "");
	I_Method0(osg::BoundingSphere, computeBound,
	          Properties::VIRTUAL,
	          __osg_BoundingSphere__computeBound,
	          "Compute the bounding sphere around Node's geometry or children. ",
	          "This method is automatically called by getBound() when the bounding sphere has been marked dirty via dirtyBound(). ");
	I_SimpleProperty(const osgVolume::BrickID &, BrickID, 
	                 __C5_BrickID_R1__getBrickID, 
	                 __void__setBrickID__C5_BrickID_R1);
	I_SimpleProperty(bool, Dirty, 
	                 __bool__getDirty, 
	                 __void__setDirty__bool);
	I_SimpleProperty(osg::Image *, Image, 
	                 __osg_Image_P1__getImage, 
	                 __void__setImage__osg_Image_P1);
	I_SimpleProperty(osg::RefMatrix *, Locator, 
	                 __osg_RefMatrix_P1__getLocator, 
	                 __void__setLocator__osg_RefMatrix_P1);
	I_SimpleProperty(osgVolume::Volume *, Volume, 
	                 __Volume_P1__getVolume, 
	                 __void__setVolume__Volume_P1);
	I_SimpleProperty(osgVolume::VolumeTechnique *, VolumeTechnique, 
	                 __VolumeTechnique_P1__getVolumeTechnique, 
	                 __void__setVolumeTechnique__VolumeTechnique_P1);
END_REFLECTOR

BEGIN_VALUE_REFLECTOR(osgVolume::BrickID)
	I_DeclaringFile("osgVolume/Brick");
	I_Constructor0(____BrickID,
	               "",
	               "");
	I_Constructor3(IN, int, in_level, IN, int, in_x, IN, int, in_y,
	               ____BrickID__int__int__int,
	               "",
	               "");
	I_Method0(bool, valid,
	          Properties::NON_VIRTUAL,
	          __bool__valid,
	          "",
	          "");
	I_PublicMemberProperty(int, level);
	I_PublicMemberProperty(int, x);
	I_PublicMemberProperty(int, y);
	I_PublicMemberProperty(int, z);
END_REFLECTOR

