/*  -*-c++-*- 
 *  Copyright (C) 2009 Cedric Pinson <cedric.pinson@plopbyte.net>
 *
 * This library is open source and may be redistributed and/or modified under  
 * the terms of the OpenSceneGraph Public License (OSGPL) version 0.0 or 
 * (at your option) any later version.  The full license is in LICENSE file
 * included with this distribution, and on the openscenegraph.org website.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the 
 * OpenSceneGraph Public License for more details.
*/

#ifndef OSGANIMATION_ACTION_H
#define OSGANIMATION_ACTION_H

#include <osgAnimation/Export>
#include <osgAnimation/Animation>
#include <osgAnimation/ActionVisitor>
#include <osgAnimation/FrameAction>
#include <iostream>

#define META_Action(library,name) \
        virtual osg::Object* cloneType() const { return new name (); } \
        virtual osg::Object* clone(const osg::CopyOp& copyop) const { return new name (*this,copyop); } \
        virtual bool isSameKindAs(const osg::Object* obj) const { return dynamic_cast<const name *>(obj)!=NULL; } \
        virtual const char* className() const { return #name; } \
        virtual const char* libraryName() const { return #library; } \
        virtual void accept(osgAnimation::ActionVisitor& nv) { nv.apply(*this); } \


namespace osgAnimation
{

    class OSGANIMATION_EXPORT Action : public osg::Object
    {
    public:

        class Callback : public osg::Object
        {
        public:
            Callback(){}
            Callback(const Callback& nc,const osg::CopyOp&) :
                _nestedCallback(nc._nestedCallback) {}

            META_Object(osgAnimation,Callback);
        
            virtual void operator()(Action* action, osgAnimation::ActionVisitor* nv) {}
            
            Callback* getNestedCallback() { return _nestedCallback.get(); } 
            void addNestedCallback(Callback* callback) 
            { 
                if (_nestedCallback.valid())
                    _nestedCallback->addNestedCallback(callback);
                else
                    _nestedCallback = callback;
            }

        protected:
            osg::ref_ptr<Callback> _nestedCallback;
        };


        typedef std::map<unsigned int, osg::ref_ptr<Callback> > FrameCallback;

        META_Action(osgAnimation, Action);
        
        Action();
        Action(const Action&,const osg::CopyOp&);

        void setCallback(double when, Callback* callback)
        {
            setCallback(static_cast<unsigned int>(floor(when*_fps)), callback);
        }

        void setCallback(unsigned int frame, Callback* callback)
        {
            if (_framesCallback[frame].valid())
                _framesCallback[frame]->addNestedCallback(callback);
            else
                _framesCallback[frame] = callback;
        }
        Callback* getCallback(unsigned int frame)
        {
            if (_framesCallback.find(frame) == _framesCallback.end())
                return 0;
            return _framesCallback[frame].get();
        }
        
        Callback* getFrameCallback(unsigned int frame);
        Callback* getFrameCallback(double time);
        unsigned int getFramesPerSecond() const { return _fps; }

        void setNumFrames(unsigned int numFrames) { _numberFrame = numFrames;}
        void setDuration(double duration) { _numberFrame = static_cast<unsigned int>(floor(duration * _fps)); }
        unsigned int getNumFrames() const { return _numberFrame;}
        double getDuration() const { return _numberFrame * 1.0 / _fps; }

        // 0 means infini else it's the number of loop
        virtual void setLoop(int nb) { _loop = nb; }
        virtual unsigned int getLoop() const { return _loop;}

        // get the number of loop, the frame relative to loop.
        // return true if in range, and false if out of range.
        bool evaluateFrame(unsigned int frame, unsigned int& resultframe, unsigned int& nbloop );
        virtual void traverse(ActionVisitor& visitor) {}
        //virtual void evaluate(unsigned int frame);

    protected:
        FrameCallback _framesCallback;

        double _speed;
        unsigned int _fps;
        unsigned int _numberFrame;
        unsigned int _loop;

        enum Status
        {
            Play,
            Stop
        };
        
        Status _state;
    };




    // blend in from 0 to weight in duration
    class BlendIn : public Action
    {
        double _weight;
        osg::ref_ptr<Animation> _animation;

    public:
        META_Action(osgAnimation, BlendIn);
        BlendIn() : _weight(0) {}
        BlendIn(const BlendIn& a, const osg::CopyOp& c) : Action(a,c) { _weight = a._weight; _animation = a._animation;}
        BlendIn(Animation* animation, double duration, double weight);
        double getWeight() const { return _weight;}
        Animation* getAnimation() { return _animation.get(); }
        void computeWeight(unsigned int frame);
    };

    // blend in from 0 to weight in duration
    class BlendOut : public Action
    {
        double _weight;
        osg::ref_ptr<Animation> _animation;
    public:
        META_Action(osgAnimation, BlendOut);
        BlendOut() : _weight(0) {}
        BlendOut(const BlendOut& a, const osg::CopyOp& c) : Action(a,c) { _weight = a._weight; _animation = a._animation;}
        BlendOut(Animation* animation, double duration);
        Animation* getAnimation() { return _animation.get(); }
        double getWeight() const { return _weight;}
        void computeWeight(unsigned int frame);
    };


    class ActionAnimation : public Action
    {
    public:
        META_Action(osgAnimation, ActionAnimation);
        ActionAnimation() {}
        ActionAnimation(const ActionAnimation& a, const osg::CopyOp& c) : Action(a,c) { _animation = a._animation;}
        ActionAnimation(Animation* animation);
        void updateAnimation(unsigned int frame);
        Animation* getAnimation() { return _animation.get(); }

    protected:
        osg::ref_ptr<Animation> _animation;
    };


    // encapsulate animation with blend in blend out for classic usage
    class StripAnimation : public Action
    {
    public:
        META_Action(osgAnimation, StripAnimation);
        StripAnimation() {}
        StripAnimation(const StripAnimation& a, const osg::CopyOp& c);
        StripAnimation(Animation* animation, double blendInDuration = 0.0, double blendOutDuration = 0.0, double blendInWeightTarget = 1.0  );
        ActionAnimation* getActionAnimation() { return _animation.get(); }
        BlendIn* getBlendIn() { return _blendIn.get(); }
        BlendOut* getBlendOut() { return _blendOut.second.get(); }
        const ActionAnimation* getActionAnimation() const { return _animation.get(); }
        const BlendIn* getBlendIn() const { return _blendIn.get(); }
        const BlendOut* getBlendOut() const { return _blendOut.second.get(); }
        unsigned int getBlendOutStartFrame() const { return _blendOut.first; }
        
        unsigned int getLoop() const { return _animation->getLoop(); }
        void setLoop(unsigned int loop);
        void computeWeightAndUpdateAnimation(unsigned int frame);

    protected:
        typedef std::pair<unsigned int, osg::ref_ptr<BlendOut> > FrameBlendOut;
        osg::ref_ptr<BlendIn> _blendIn;
        FrameBlendOut _blendOut;
        osg::ref_ptr<ActionAnimation> _animation;
    };



}

#endif
