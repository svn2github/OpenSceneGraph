/* -*-c++-*- OpenSceneGraph - Copyright (C) 1998-2010 Robert Osfield
 *
 * This library is open source and may be redistributed and/or modified under
 * the terms of the OpenSceneGraph Public License (OSGPL) version 0.0 or
 * (at your option) any later version.  The full license is in LICENSE file
 * included with this distribution, and on the openscenegraph.org website.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * OpenSceneGraph Public License for more details.
*/
// Written by Wang Rui, (C) 2010

#ifndef H_INPUTSTREAM
#define H_INPUTSTREAM

#include <osg/Endian>
#include <osg/Vec2>
#include <osg/Vec3>
#include <osg/Vec4>
#include <osg/Quat>
#include <osg/Matrix>
#include <osg/Array>
#include <osg/PrimitiveSet>
#include <osgDB/ReaderWriter>
#include <osgDB/DataTypes>
#include <iostream>
#include <sstream>

namespace osgDB
{

class InputException
{
public:
    InputException( const std::string& field, const std::string& err )
    : _field(field), _error(err) {}
    
    const std::string& getField() const { return _field; }
    const std::string& getError() const { return _error; }
    
protected:
    std::string _field;
    std::string _error;
};

class OSGDB_EXPORT InputStream
{
public:
    typedef std::map< unsigned int, osg::ref_ptr<osg::Array> > ArrayMap;
    typedef std::map< unsigned int, osg::ref_ptr<osg::Object> > IdentifierMap;
    
    enum ReadMode
    {
        READ_BINARY = 0,
        READ_ASCII
    };
    
    enum ReadType
    {
        READ_UNKNOWN = 0,
        READ_SCENE,
        READ_IMAGE
    };
    
    InputStream( std::istream* istream, const osgDB::Options* options );
    virtual ~InputStream();
    
    bool isBinary() const { return _readMode==READ_BINARY; }
    bool getUseFloatMatrix() const { return _useFloatMatrix; }
    
    // Serialization related functions
    inline InputStream& operator>>( bool& b );
    inline InputStream& operator>>( char& c );
    inline InputStream& operator>>( signed char& c );
    inline InputStream& operator>>( unsigned char& c );
    inline InputStream& operator>>( short& s );
    inline InputStream& operator>>( unsigned short& s );
    inline InputStream& operator>>( int& i );
    inline InputStream& operator>>( unsigned int& i );
    inline InputStream& operator>>( long& l );
    inline InputStream& operator>>( unsigned long& l );
    inline InputStream& operator>>( float& f );
    inline InputStream& operator>>( double& d );
    inline InputStream& operator>>( std::string& s );
    inline InputStream& operator>>( std::istream& (*fn)(std::istream&) );
    inline InputStream& operator>>( std::ios_base& (*fn)(std::ios_base&) );
    
    InputStream& operator>>( osg::Vec2b& v );
    InputStream& operator>>( osg::Vec3b& v );
    InputStream& operator>>( osg::Vec4b& v );
    InputStream& operator>>( osg::Vec4ub& v );
    InputStream& operator>>( osg::Vec2s& v );
    InputStream& operator>>( osg::Vec3s& v );
    InputStream& operator>>( osg::Vec4s& v );
    InputStream& operator>>( osg::Vec2f& v );
    InputStream& operator>>( osg::Vec3f& v );
    InputStream& operator>>( osg::Vec4f& v );
    InputStream& operator>>( osg::Vec2d& v );
    InputStream& operator>>( osg::Vec3d& v );
    InputStream& operator>>( osg::Vec4d& v );
    InputStream& operator>>( osg::Quat& q );
    InputStream& operator>>( osg::Plane& p );
    InputStream& operator>>( osg::Matrixf& mat );
    InputStream& operator>>( osg::Matrixd& mat );
    
    InputStream& operator>>( osg::Array*& a ) { a = readArray(); return *this; }
    InputStream& operator>>( osg::Image*& img ) { img = readImage(); return *this; }
    InputStream& operator>>( osg::PrimitiveSet*& p ) { p = readPrimitiveSet(); return *this; }
    InputStream& operator>>( osg::Object*& obj ) { obj = readObject(); return *this; }
    
    InputStream& operator>>( osg::ref_ptr<osg::Array>& ptr ) { ptr = readArray(); return *this; }
    InputStream& operator>>( osg::ref_ptr<osg::Image>& ptr ) { ptr = readImage(); return *this; }
    InputStream& operator>>( osg::ref_ptr<osg::PrimitiveSet>& ptr ) { ptr = readPrimitiveSet(); return *this; }
    
    template<typename T> InputStream& operator>>( osg::ref_ptr<T>& ptr )
    { ptr = static_cast<T*>(readObject()); return *this; }
    
    InputStream& operator>>( ObjectGLenum& value );
    InputStream& operator>>( ObjectProperty& prop );
    InputStream& operator>>( ObjectMark& mark );
    
    // Convenient methods for reading
    inline bool matchString( const std::string& str );
    inline void advanceToCurrentEndBracket();
    inline void readWrappedString( std::string& str );
    inline void readCharArray( char* s, unsigned int size );
    
    // Global reading functions
    osg::Array* readArray();
    osg::PrimitiveSet* readPrimitiveSet();
    osg::Image* readImage();
    osg::Object* readObject( osg::Object* existingObj=0 );
    
    ReadType start();
    void decompress();
    
    // Schema handlers
    void readSchema( std::istream& fin );
    void resetSchema();
    
protected:
    inline void checkStream() const;
    void setWrapperSchema( const std::string& name, const std::string& properties );
    
    template<typename T>
    void readArrayImplementation( T* a, int readSize, bool useByteSwap=false );
    
    ArrayMap _arrayMap;
    IdentifierMap _identifierMap;
    
    ReadMode _readMode;
    int _byteSwap;
    bool _useFloatMatrix;
    std::string _currentField;
    std::istream* _in;
};

// INLINE METHODS

InputStream& InputStream::operator>>( bool& b )
{
    if ( isBinary() )
    {
        char c = 0;
        _in->read( &c, CHAR_SIZE ); checkStream();
        b = (c!=0);
    }
    else
    {
        std::string boolString;
        *_in >> boolString; checkStream();
        if ( boolString=="TRUE" ) b = true;
        else b = false;
    }
    return *this;
}

InputStream& InputStream::operator>>( char& c )
{
    if ( isBinary() )
    {
        _in->read( &c, CHAR_SIZE ); checkStream();
    }
    else
    {
        short s = 0;
        *_in >> s; checkStream();
        c = (char)s;
    }
    return *this;
}

InputStream& InputStream::operator>>( signed char& c )
{
    if ( isBinary() )
    {
        _in->read( (char*)&c, CHAR_SIZE ); checkStream();
    }
    else
    {
        short s = 0;
        *_in >> s; checkStream();
        c = (signed char)s;
    }
    return *this;
}

InputStream& InputStream::operator>>( unsigned char& c )
{
    if ( isBinary() )
    {
        _in->read( (char*)&c, CHAR_SIZE ); checkStream();
    }
    else
    {
        unsigned short s = 0;
        *_in >> s; checkStream();
        c = (unsigned char)s;
    }
    return *this;
}

InputStream& InputStream::operator>>( short& s )
{
    if ( isBinary() )
    {
        _in->read( (char*)&s, SHORT_SIZE ); checkStream();
        if ( _byteSwap ) osg::swapBytes( (char*)&s, SHORT_SIZE );
    }
    else
    {
        *_in >> s; checkStream();
    }
    return *this;
}

InputStream& InputStream::operator>>( unsigned short& s )
{
    if ( isBinary() )
    {
        _in->read( (char*)&s, SHORT_SIZE ); checkStream();
        if ( _byteSwap ) osg::swapBytes( (char*)&s, SHORT_SIZE );
    }
    else
    {
        *_in >> s; checkStream();
    }
    return *this;
}

InputStream& InputStream::operator>>( int& i )
{
    if ( isBinary() )
    {
        _in->read( (char*)&i, INT_SIZE ); checkStream();
        if ( _byteSwap ) osg::swapBytes( (char*)&i, INT_SIZE );
    }
    else
    {
        *_in >> i; checkStream();
    }
    return *this;
}

InputStream& InputStream::operator>>( unsigned int& i )
{
    if ( isBinary() )
    {
        _in->read( (char*)&i, INT_SIZE ); checkStream();
        if ( _byteSwap ) osg::swapBytes( (char*)&i, INT_SIZE );
    }
    else
    {
        *_in >> i; checkStream();
    }
    return *this;
}

InputStream& InputStream::operator>>( long& l )
{
    if ( isBinary() )
    {
        _in->read( (char*)&l, LONG_SIZE ); checkStream();
        if ( _byteSwap ) osg::swapBytes( (char*)&l, LONG_SIZE );
    }
    else
    {
        *_in >> l; checkStream();
    }
    return *this;
}

InputStream& InputStream::operator>>( unsigned long& l )
{
    if ( isBinary() )
    {
        _in->read( (char*)&l, LONG_SIZE ); checkStream();
        if ( _byteSwap ) osg::swapBytes( (char*)&l, LONG_SIZE );
    }
    else
    {
        *_in >> l; checkStream();
    }
    return *this;
}

InputStream& InputStream::operator>>( float& f )
{
    if ( isBinary() )
    {
        _in->read( (char*)&f, FLOAT_SIZE ); checkStream();
        if ( _byteSwap ) osg::swapBytes( (char*)&f, FLOAT_SIZE );
    }
    else
    {
        *_in >> f; checkStream();
    }
    return *this;
}

InputStream& InputStream::operator>>( double& d )
{
    if ( isBinary() )
    {
        _in->read( (char*)&d, DOUBLE_SIZE ); checkStream();
        if ( _byteSwap ) osg::swapBytes( (char*)&d, DOUBLE_SIZE );
    }
    else
    {
        *_in >> d; checkStream();
    }
    return *this;
}

InputStream& InputStream::operator>>( std::string& s )
{
    if ( isBinary() )
    {
        int size = 0; *this >> size;
        if ( size )
        {
            s.resize( size );
            _in->read( (char*)s.c_str(), size ); checkStream();
        }
    }
    else
    {
        *_in >> s; checkStream();
    }
    return *this;
}

InputStream& InputStream::operator>>( std::istream& (*fn)(std::istream&) )
{
    if ( !isBinary() ) *_in >> fn;
    return *this;
}

InputStream& InputStream::operator>>( std::ios_base& (*fn)(std::ios_base&) )
{
    if ( !isBinary() ) *_in >> fn;
    return *this;
}

bool InputStream::matchString( const std::string& str )
{
    if ( !isBinary() )
    {
        std::string s;
        *_in >> s; checkStream();
        if ( s==str ) return true;
        else _in->seekg( -(int)(s.length()), std::ios::cur );
    }
    return false;
}

void InputStream::advanceToCurrentEndBracket()
{
    if ( isBinary() )
        return;
    
    std::string passString;
    unsigned int blocks = 0;
    while ( !_in->eof() )
    {
        passString.clear();
        *_in >> passString;
        
        if ( passString=="}" )
        {
            if ( blocks<=0 ) return;
            else blocks--;
        }
        else if ( passString=="{" )
            blocks++;
    }
}

void InputStream::readWrappedString( std::string& str )
{
    *this >> str;
    if ( !isBinary() )
    {
        if ( str[0]=='\"' )
        {
            if ( str.size()==1 || (*str.rbegin())!='\"' )
            {
                char ch;
                do
                {
                    _in->get( ch ); checkStream();
                    str.append( 1, ch );
                } while ( ch!='\"' );
            }
            str = str.substr(1, str.size()-2);
        }
    }
}

void InputStream::readCharArray( char* s, unsigned int size )
{
    if ( size>0 )
    {
        _in->read( s, size ); checkStream();
    }
}

void InputStream::checkStream() const
{
    if ( _in->rdstate()&_in->failbit )
        throw InputException(_currentField, "InputStream: Failed to read from stream.");
}

}

#endif
