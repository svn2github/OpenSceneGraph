/* -*-c++-*- OpenSceneGraph - Copyright (C) 1998-2006 Robert Osfield
 *
 * This library is open source and may be redistributed and/or modified under
 * the terms of the OpenSceneGraph Public License (OSGPL) version 0.0 or
 * (at your option) any later version.  The full license is in LICENSE file
 * included with this distribution, and on the openscenegraph.org website.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * OpenSceneGraph Public License for more details.
*/

#ifndef OSGSHADOW_VIEWDEPENDENTSHADOWMAP
#define OSGSHADOW_VIEWDEPENDENTSHADOWMAP 1

#include <osg/Camera>
#include <osg/Material>
#include <osg/MatrixTransform>
#include <osg/LightSource>

#include <osgShadow/ShadowTechnique>

namespace osgShadow {

/** ViewDependentShadowMap provides an base implementation of view dependent shadow mapping techniques.*/
class OSGSHADOW_EXPORT ViewDependentShadowMap : public ShadowTechnique
{
    public :
        ViewDependentShadowMap();

        ViewDependentShadowMap(const ViewDependentShadowMap& vdsm, const osg::CopyOp& copyop=osg::CopyOp::SHALLOW_COPY);

        META_Object(osgShadow, ViewDependentShadowMap);

        /** initialize the ShadowedScene and local cached data structures.*/
        virtual void init();

        /** run the update traversal of the ShadowedScene and update any loca chached data structures.*/
        virtual void update(osg::NodeVisitor& nv);

        /** run the cull traversal of the ShadowedScene and set up the rendering for this ShadowTechnique.*/
        virtual void cull(osgUtil::CullVisitor& cv);

        /** Clean scene graph from any shadow technique specific nodes, state and drawables.*/
        virtual void cleanSceneGraph();

        struct OSGSHADOW_EXPORT LightShadowData : public osg::Referenced
        {
            unsigned int                _textureUnit;
            osg::ref_ptr<osg::Texture>  _texture;
            osg::ref_ptr<osg::TexGen>   _texgen;

            osg::ref_ptr<osg::Light>    _light;
            osg::ref_ptr<osg::Camera>   _camera;
        };
        
        class OSGSHADOW_EXPORT ViewDependentData : public osg::Referenced
        {
        public:
            ViewDependentData(ViewDependentShadowMap* vdsm, osgUtil::CullVisitor* cv);

            
            
            void cullShadowCastingScene(osgUtil::CullVisitor* cv);
            
            void cull(osgUtil::CullVisitor*);
            
        protected:
            virtual ~ViewDependentData() {}

            osg::ref_ptr<osg::StateSet> _stateset;
        };
        
        virtual ViewDependentData* createViewDependentData(osgUtil::CullVisitor* cv);

        ViewDependentData* getViewDependentData(osgUtil::CullVisitor* cv);

        struct OSGSHADOW_EXPORT Frustum
        {
            Frustum(osgUtil::CullVisitor* cv);

            osg::Matrixd projectionMatrix;
            osg::Matrixd modelViewMatrix;
            
            typedef std::vector<osg::Vec3d> Vertices;
            Vertices corners;
            
            typedef std::vector<unsigned int> Indices;
            typedef std::vector<Indices> Faces;
            Faces faces;

            typedef std::vector<Indices> Edges;
            Edges edges;

            osg::Vec3d centerNearPlane;
            osg::Vec3d centerFarPlane;
            osg::Vec3d center;
            osg::Vec3d frustumCenterLine;
        };

        struct OSGSHADOW_EXPORT PositionedLight
        {
            PositionedLight(osg::RefMatrix* lm, const osg::Light* l, const osg::Matrixd& modelViewMatrix);
            
            osg::ref_ptr<osg::RefMatrix>        lightMatrix;
            osg::ref_ptr<const osg::Light>      light;

            osg::Vec4d                          lightPos;
            osg::Vec3d                          lightPos3;
            osg::Vec3d                          lightDir;
            bool                                directionalLight;

            typedef std::vector<unsigned int> ActiveTextureUnits;
            ActiveTextureUnits                   textureUnits;
        };
        
        typedef std::list< PositionedLight > PositionedLightList;

        virtual bool selectActiveLights(osgUtil::CullVisitor* cv, PositionedLightList& pll) const;

        virtual osg::Polytope computeLightViewFrustumPolytope(Frustum& frustum, PositionedLight& positionedLight);

        virtual bool computeShadowCameraSettings(Frustum& frustum, PositionedLight& positionedLight, osg::Camera* camera);

        virtual bool assignTexGenSettings(osgUtil::CullVisitor* cv, osg::Camera* camera, unsigned int textureUnit, osg::TexGen* texgen);

        virtual void cullShadowReceivingScene(osgUtil::CullVisitor* cv, osg::StateSet* stateset) const;

        virtual void cullShadowCastingScene(osgUtil::CullVisitor* cv, osg::Camera* camera) const;


protected:
        virtual ~ViewDependentShadowMap();

        typedef std::map< osgUtil::CullVisitor*, osg::ref_ptr<ViewDependentData> >  ViewDependentDataMap;
        OpenThreads::Mutex   _viewDependentDataMapMutex;
        ViewDependentDataMap _viewDependentDataMap;
        
};

}

#endif
